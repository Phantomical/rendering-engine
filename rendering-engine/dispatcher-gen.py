#Copyright (C) 2016 Sean Lynch

#	This file is part of rendering-engine.
#	
#	rendering-engine is free software : you can redistribute it and / or modify
#	it under the terms of the GNU Lesser General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#	
#	rendering-engine is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
#	GNU Lesser General Public License for more details.
#	
#	You should have received a copy of the GNU Lesser General Public License
#	along with rendering-engine. If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import xml.etree.ElementTree as ET
import sys

file = sys.argv[1]
outfile = sys.argv[2]
namespace = "gldr"

tree = ET.parse(file)
root = tree.getroot()

output = ""
level = 0

class func_t:
    def __init__(self, name, rettype, args, nargs, sync):
        self.name = name
        self.rettype = rettype
        self.args = args
        self.nargs = nargs
        self.sync = sync

def getlevel():
    global level
    tabs = ""
    for i in range(0, level):
        tabs +="\t"
    return tabs

def write(val):
    global output
    output += getlevel() + val + "\n"

write("""/*
    This file was generated by dispatcher-gen.py as part of the project build.

	This file is part of rendering-engine.
	
	rendering-engine is free software : you can redistribute it and / or modify
	it under the terms of the GNU Lesser General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	rendering-engine is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
	GNU Lesser General Public License for more details.
	
	You should have received a copy of the GNU Lesser General Public License
	along with rendering-engine. If not, see <http://www.gnu.org/licenses/>.
*/
""")

write("#include \"allocators.h\"")
write("#include \"interface.h\"")
write("#include <functional>")
write("")
write("#define CALL_CONV " + namespace.upper() + "_BACKEND_CALL_CONV")
write("")
write("void* load_init(const char*);")
write("void* load_func(void*, const char*);")
write("void load_terminate(void*);")
write("")
write("namespace " + namespace)
write("{")
level += 1

#create list of functions
funcs = list()

for func in root.findall("function"):
    if func.find("no-implement") != None:
        #Don't implement the function if we aren't supposed to
        continue
    name = func.get("name")
    if name == None:
        print("Invalid function declaration detected")
        continue
    ret = func.find("return")
    if ret == None:
        print("No return type provided for the function")
        continue
    rettype = ret.get("type")
    if rettype == None:
        print("Invalid return declaration detected")
        continue
    cond = False
    args = ""
    cnt = 0
    for arg in func.findall("arg"):
       type = arg.get("type")
       if type == None:
           print("Invalid argument declaration in function " + name)
           continue
       if cond:
          args += ", "
       else:
           cond = True
       args += type + " arg" + str(cnt)
       cnt += 1
    funcs.append(func_t(name, rettype, args, cnt, func.find("sync") != None))

#declare typedefs
for func in funcs:
    if func.rettype == "void":
        write("typedef " + func.rettype + "(CALL_CONV*" + func.name + "_proc)(" + func.args + ");")
    else:
        args = ""
        if func.nargs != 0:
            args = ", " + func.args
        write("typedef void(CALL_CONV*" + func.name + "_proc)(" + func.rettype + "*" + args + ");")

write("")
write("struct backend::state")
write("{")
level += 1

#declare variables
for func in funcs:
    write(func.name + "_proc " + func.name +"_func;")

#Backend terminate function, we don't store the init function because we won't need it later
write("void(*terminate_func)();")
write("void* handle;");
write("allocators::linear_atomic alloc;")
write("")
write("state() :")
write("\talloc(1 << 16)")
write("{ }")

level -= 1
write("};")
write("")

#declare prototypes
for func in funcs:
    cond = False
    decl = ""
    write(func.rettype + " backend::" + func.name + "(" + func.args + ")")
    write("{")
    level += 1
    for i in range(func.nargs):
        if cond:
            decl += ", "
        else:
            cond = True
        decl += "arg" + str(i)
    if func.sync:
        write("struct cb {")
        level += 1
        write("std::function<void()> f;")
        write("cb(const std::function<void()>& v) : f(v) { }")
        write("~cb() { f(); }")
        level -= 1
        write("} c([=](){ this->sync_callback(); });")
    if func.rettype == "void":
        write("_state->" + func.name + "_func(" + decl + ");")
    else:
        write(func.rettype + " _retval;")
        if func.nargs == 0:
            write("_state->" + func.name + "_func(&_retval);")
        else:
            write("_state->" + func.name + "_func(&_retval, " + decl + ");")
        write("return _retval;")
    level -= 1
    write("}")

write("")

#init method
write("void backend::init(const std::string& lib)")
write("{")
level += 1
write("_state = new state;")

write("_state->handle = load_init(lib.c_str());")

for func in funcs:
    write("_state->" + func.name + "_func = reinterpret_cast<" + func.name 
        + "_proc>(load_func(_state->handle, \"_" + func.name + "\"));")

write("_state->terminate_func = reinterpret_cast<decltype(_state->terminate_func)>(load_func(_state->handle, \"_terminate\"));")
write("void(*init_func)() = reinterpret_cast<void(*)()>(load_func(_state->handle, \"_init\"));")
write("if (init_func)")
write("{")
level += 1
write("init_func();")
level -= 1
write("}")
write("else")
write("{")
level += 1
write("delete _state;")
write("_state = nullptr;")
level -= 1
write("}")

level -= 1
write("}")

write("void backend::terminate()")
write("{")
level += 1
write("if (_state != nullptr)")
write("{")
level += 1
write("_state->terminate_func();")
write("load_terminate(_state->handle);")
write("delete _state;")
level -= 1
write("}")
level -= 1
write("}")

write("backend::backend(const std::string& backend_lib)")
write("{")
level += 1
write("init(backend_lib);")
level -= 1
write("}")

write("backend::~backend()")
write("{")
level += 1
write("terminate();")
level -= 1
write("}")

write("bool backend::is_valid() const")
write("{")
level += 1
write("return _state != nullptr;")
level -= 1
write("}")

write("allocators::linear_atomic* backend::allocator()")
write("{")
level += 1
write("return &_state->alloc;")
level -= 1
write("}")

level -= 1
write("}")
    
with open(outfile, "w") as f:
    f.write(output)
